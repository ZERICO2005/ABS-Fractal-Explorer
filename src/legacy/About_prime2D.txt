2023/11/07

"prime2D.h" was the name of the file that contained the graphics routines I used for Super-Sweeper on the Ti84CE. I even had an assembly routine to fill a rectangle in eZ80 assembly.

The printInt and printUInt functions were quite useful for developing on the Ti84CE, as it would allow me to print numbers on screen for debugging purposes. The code was used for similiar purposes in early versions of ABS-Fractal-Explorer; such as displaying the framerate before I added the UI. I also did some modifications to the function to add support for floats.

Below is the original code used on the Ti84CE, which uses 24 bit integers.

===========================
As of 2023, May 30th, 22:49
===========================

//Debugging
const uint16_t num3x5[16] = {0x7B6F, 0x749A, 0x73E7, 0x79A7, 0x49ED, 0x79CF, 0x7BCF, 0x24A7, 0x7AAF, 0x79EF,    0x5BEF, 0x7BC9, 0x724F, 0x7BE4, 0x72CF, 0x12CF}; //Used for the printInt functions
void printInt(int24_t in, uint8_t len, uint8_t base, uint24_t xC, uint24_t yC) { //integer to print, length, base 2-16 //Auto adjusts for signage
    uint8_t* off = (uint8_t*)VRAM + xC + (320 * yC);
    uint8_t* v = off + 320;
    len <<= 2; //len * 4
    const uint24_t x2 = 5 + len;
    const uint24_t jump = 317 - x2;
    for (uint8_t dY = 1; dY < 6; dY++) {
        for (uint24_t dX = 0; dX < x2; dX += 4) {
            *v = 0;
            v += 4;
        }
        v += jump;
    }
    v = off;
    for (uint24_t dX = 0; dX < x2; dX++) {
        *v = 0;
        v++;
    }
    v = off + 1920; // 320 * 6
    for (uint24_t dX = 0; dX < x2; dX++) {
        *v = 0;
        v++;
    }

    uint24_t* negSign = 961 + (uint24_t*)off; //Fills three pixels //1 + (3 * 320)
    *negSign = in < 0 ? 460551 : 0; //If Negative
    uint24_t j = abs(in);
    uint24_t pow = 1;
    for (uint24_t k = 0; k < len; k += 4) {
        uint16_t bitImage = num3x5[(j / pow) % base];
        uint8_t *fill = off + 321 + len - k;
        for (uint8_t y = 0; y < 5; y++) {
            for (uint8_t x = 0; x < 3; x++) {
                *fill = bitImage & 1 ? 7 : 0; //White if true
                bitImage >>= 1;
                fill++;
            }
            fill += 317; //320 - 3
        }
        pow *= base;
    }
}
void printUInt(int24_t in, uint8_t len, uint8_t base, uint24_t xC, uint24_t yC) { //integer to print, length, base 2-16
    uint8_t* off = (uint8_t*)VRAM + xC + (320 * yC); //Something about casting off to uint8_t* adds 4 more bytes
    uint8_t* v = off + 320;
    len <<= 2; //len * 4
    const uint24_t x2 = 1 + len; //Can optomize out "1 + " for a saving of 8 bytes
    const uint24_t jump = 317 - x2;
    for (uint8_t dY = 1; dY < 6; dY++) {
        for (uint24_t dX = 0; dX < x2; dX += 4) {
            *v = 0;
            v += 4;
        }
        v += jump;
    }
    v = off;
    for (uint24_t dX = 0; dX < x2; dX++) {
        *v = 0;
        v++;
    }
    v = off + 1920; // 320 * 6
    for (uint24_t dX = 0; dX < x2; dX++) {
        *v = 0;
        v++;
    }
    uint24_t pow = 1;
    for (uint24_t k = 0; k < len; k += 4) {
        uint16_t bitImage = num3x5[(in / pow) % base];
        uint8_t* fill = off + 317 + len - k;
        for (uint8_t y = 0; y < 5; y++) {
            for (uint8_t x = 0; x < 3; x++) {
                *fill = bitImage & 1 ? 7 : 0; //White if true
                bitImage >>= 1;
                fill++;
            }
            fill += 317; //320 - 3
        }
        pow *= base;
    }
}